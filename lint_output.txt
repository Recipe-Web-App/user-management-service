internal/service/user_service.go:199:1: calculated cyclomatic complexity for function UpdateUserProfile is 11, max is 10 (cyclop)
func (s *UserServiceImpl) UpdateUserProfile(
^
internal/handler/social.go:115: 115-159 lines are duplicate of `internal/handler/social.go:164-208` (dupl)
func (h *SocialHandler) FollowUser(w http.ResponseWriter, r *http.Request) {
	// 1. Extract and validate requester ID from header (authenticated user)
	requesterID, ok := h.extractAuthenticatedUserID(w, r)
	if !ok {
		return
	}

	// 2. Extract and validate user_id from path (the user performing the follow)
	userIDStr := chi.URLParam(r, "user_id")

	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		ErrorResponse(w, http.StatusUnprocessableEntity, "VALIDATION_ERROR", "Invalid user ID format")

		return
	}

	// 3. Authorization check: path user_id must match authenticated user OR user is admin
	isAdmin := h.isAdminUser(r)
	if userID != requesterID && !isAdmin {
		ForbiddenResponse(w, "Cannot perform follow action for another user")

		return
	}

	// 4. Extract and validate target_user_id from path
	targetUserIDStr := chi.URLParam(r, "target_user_id")

	targetUserID, err := uuid.Parse(targetUserIDStr)
	if err != nil {
		ErrorResponse(w, http.StatusUnprocessableEntity, "VALIDATION_ERROR", "Invalid target user ID format")

		return
	}

	// 5. Call service (use path user_id as follower, not requester, for admin override)
	response, err := h.socialService.FollowUser(r.Context(), userID, targetUserID)
	if err != nil {
		h.handleFollowUserError(w, err)

		return
	}

	SuccessResponse(w, http.StatusOK, response)
}
internal/handler/social.go:315: 315-361 lines are duplicate of `internal/handler/notification.go:281-327` (dupl)
func (h *SocialHandler) parseFollowingParams(r *http.Request) (*followingParams, error) {
	params := &followingParams{
		limit:     defaultLimit,
		offset:    0,
		countOnly: false,
	}

	// Parse limit
	if limitStr := r.URL.Query().Get("limit"); limitStr != "" {
		limit, err := strconv.Atoi(limitStr)
		if err != nil {
			return nil, ErrInvalidLimit
		}

		if limit < minLimit || limit > maxLimit {
			return nil, ErrLimitOutOfRange
		}

		params.limit = limit
	}

	// Parse offset
	if offsetStr := r.URL.Query().Get("offset"); offsetStr != "" {
		offset, err := strconv.Atoi(offsetStr)
		if err != nil {
			return nil, ErrInvalidOffset
		}

		if offset < 0 {
			return nil, ErrNegativeOffset
		}

		params.offset = offset
	}

	// Parse count_only
	if countOnlyStr := r.URL.Query().Get("count_only"); countOnlyStr != "" {
		countOnly, err := strconv.ParseBool(countOnlyStr)
		if err != nil {
			return nil, ErrInvalidCountOnly
		}

		params.countOnly = countOnly
	}

	return params, nil
}
internal/handler/social_test.go:156: 156-468 lines are duplicate of `internal/handler/social_test.go:471-783` (dupl)
func TestSocialHandlerGetFollowing(t *testing.T) {
	t.Parallel()

	targetID := uuid.New()
	requesterID := uuid.New()

	now := time.Now()
	limit := 20
	offset := 0
	fullName := "Jane Smith"

	baseResponse := &dto.GetFollowedUsersResponse{
		TotalCount: 1,
		FollowedUsers: []dto.User{
			{
				UserID:    uuid.New().String(),
				Username:  "janesmith",
				FullName:  &fullName,
				IsActive:  true,
				CreatedAt: now,
				UpdatedAt: now,
			},
		},
		Limit:  &limit,
		Offset: &offset,
	}

	countOnlyResponse := &dto.GetFollowedUsersResponse{
		TotalCount: 42,
	}

	emptyResponse := &dto.GetFollowedUsersResponse{
		TotalCount:    0,
		FollowedUsers: []dto.User{},
		Limit:         &limit,
		Offset:        &offset,
	}

	tests := []socialHandlerTestCase{
		{
			name:           "Success - returns following list with pagination",
			targetIDPath:   targetID.String(),
			requesterIDHdr: requesterID.String(),
			queryParams:    "",
			mockRun: func(m *MockSocialService) {
				m.On("GetFollowing", mock.Anything, requesterID, targetID, 20, 0, false).Return(baseResponse, nil)
			},
			expectedStatus: http.StatusOK,
			validateBody: func(t *testing.T, body string) {
				t.Helper()
				assert.Contains(t, body, `"success":true`)
				assert.Contains(t, body, `"totalCount":1`)
				assert.Contains(t, body, `"janesmith"`)
			},
		},
		{
			name:           "Success - count_only returns only totalCount",
			targetIDPath:   targetID.String(),
			requesterIDHdr: requesterID.String(),
			queryParams:    "count_only=true",
			mockRun: func(m *MockSocialService) {
				m.On("GetFollowing", mock.Anything, requesterID, targetID, 20, 0, true).Return(countOnlyResponse, nil)
			},
			expectedStatus: http.StatusOK,
			validateBody: func(t *testing.T, body string) {
				t.Helper()
				assert.Contains(t, body, `"success":true`)
				assert.Contains(t, body, `"totalCount":42`)
			},
		},
		{
			name:           "Success - empty following list",
			targetIDPath:   targetID.String(),
			requesterIDHdr: requesterID.String(),
			queryParams:    "",
			mockRun: func(m *MockSocialService) {
				m.On("GetFollowing", mock.Anything, requesterID, targetID, 20, 0, false).Return(emptyResponse, nil)
			},
			expectedStatus: http.StatusOK,
			validateBody: func(t *testing.T, body string) {
				t.Helper()
				assert.Contains(t, body, `"success":true`)
				assert.Contains(t, body, `"totalCount":0`)
				// Empty followedUsers is omitted due to omitempty tag
				assert.NotContains(t, body, `"followedUsers"`)
			},
		},
		{
			name:           "Success - custom pagination",
			targetIDPath:   targetID.String(),
			requesterIDHdr: requesterID.String(),
			queryParams:    "limit=50&offset=10",
			mockRun: func(m *MockSocialService) {
				m.On("GetFollowing", mock.Anything, requesterID, targetID, 50, 10, false).Return(baseResponse, nil)
			},
			expectedStatus: http.StatusOK,
			validateBody: func(t *testing.T, body string) {
				t.Helper()
				assert.Contains(t, body, `"success":true`)
			},
		},
		{
			name:           "Success - viewing own following list",
			targetIDPath:   requesterID.String(),
			requesterIDHdr: requesterID.String(),
			queryParams:    "",
			mockRun: func(m *MockSocialService) {
				m.On("GetFollowing", mock.Anything, requesterID, requesterID, 20, 0, false).Return(baseResponse, nil)
			},
			expectedStatus: http.StatusOK,
			validateBody: func(t *testing.T, body string) {
				t.Helper()
				assert.Contains(t, body, `"success":true`)
			},
		},
		{
			name:           "Unauthorized - missing X-User-Id header",
			targetIDPath:   targetID.String(),
			requesterIDHdr: "",
			queryParams:    "",
			mockRun:        func(_ *MockSocialService) {},
			expectedStatus: http.StatusUnauthorized,
			validateBody: func(t *testing.T, body string) {
				t.Helper()
				assert.Contains(t, body, "UNAUTHORIZED")
				assert.Contains(t, body, "User authentication required")
			},
		},
		{
			name:           "Unauthorized - invalid X-User-Id header",
			targetIDPath:   targetID.String(),
			requesterIDHdr: "invalid-uuid",
			queryParams:    "",
			mockRun:        func(_ *MockSocialService) {},
			expectedStatus: http.StatusUnauthorized,
			validateBody: func(t *testing.T, body string) {
				t.Helper()
				assert.Contains(t, body, "UNAUTHORIZED")
				assert.Contains(t, body, "Invalid user ID in authentication header")
			},
		},
		{
			name:           "Validation Error - invalid UUID format",
			targetIDPath:   "invalid-uuid",
			requesterIDHdr: requesterID.String(),
			queryParams:    "",
			mockRun:        func(_ *MockSocialService) {},
			expectedStatus: http.StatusUnprocessableEntity,
			validateBody: func(t *testing.T, body string) {
				t.Helper()
				assert.Contains(t, body, "VALIDATION_ERROR")
				assert.Contains(t, body, "Invalid user ID format")
			},
		},
		{
			name:           "Validation Error - invalid limit",
			targetIDPath:   targetID.String(),
			requesterIDHdr: requesterID.String(),
			queryParams:    "limit=abc",
			mockRun:        func(_ *MockSocialService) {},
			expectedStatus: http.StatusBadRequest,
			validateBody: func(t *testing.T, body string) {
				t.Helper()
				assert.Contains(t, body, "VALIDATION_ERROR")
				assert.Contains(t, body, "limit must be a valid integer")
			},
		},
		{
			name:           "Validation Error - limit out of range (too low)",
			targetIDPath:   targetID.String(),
			requesterIDHdr: requesterID.String(),
			queryParams:    "limit=0",
			mockRun:        func(_ *MockSocialService) {},
			expectedStatus: http.StatusBadRequest,
			validateBody: func(t *testing.T, body string) {
				t.Helper()
				assert.Contains(t, body, "VALIDATION_ERROR")
				assert.Contains(t, body, "limit must be between 1 and 100")
			},
		},
		{
			name:           "Validation Error - limit out of range (too high)",
			targetIDPath:   targetID.String(),
			requesterIDHdr: requesterID.String(),
			queryParams:    "limit=101",
			mockRun:        func(_ *MockSocialService) {},
			expectedStatus: http.StatusBadRequest,
			validateBody: func(t *testing.T, body string) {
				t.Helper()
				assert.Contains(t, body, "VALIDATION_ERROR")
				assert.Contains(t, body, "limit must be between 1 and 100")
			},
		},
		{
			name:           "Validation Error - invalid offset",
			targetIDPath:   targetID.String(),
			requesterIDHdr: requesterID.String(),
			queryParams:    "offset=abc",
			mockRun:        func(_ *MockSocialService) {},
			expectedStatus: http.StatusBadRequest,
			validateBody: func(t *testing.T, body string) {
				t.Helper()
				assert.Contains(t, body, "VALIDATION_ERROR")
				assert.Contains(t, body, "offset must be a valid integer")
			},
		},
		{
			name:           "Validation Error - negative offset",
			targetIDPath:   targetID.String(),
			requesterIDHdr: requesterID.String(),
			queryParams:    "offset=-1",
			mockRun:        func(_ *MockSocialService) {},
			expectedStatus: http.StatusBadRequest,
			validateBody: func(t *testing.T, body string) {
				t.Helper()
				assert.Contains(t, body, "VALIDATION_ERROR")
				assert.Contains(t, body, "offset must be non-negative")
			},
		},
		{
			name:           "Validation Error - invalid count_only",
			targetIDPath:   targetID.String(),
			requesterIDHdr: requesterID.String(),
			queryParams:    "count_only=maybe",
			mockRun:        func(_ *MockSocialService) {},
			expectedStatus: http.StatusBadRequest,
			validateBody: func(t *testing.T, body string) {
				t.Helper()
				assert.Contains(t, body, "VALIDATION_ERROR")
				assert.Contains(t, body, "count_only must be a valid boolean")
			},
		},
		{
			name:           "Not Found - user does not exist",
			targetIDPath:   targetID.String(),
			requesterIDHdr: requesterID.String(),
			queryParams:    "",
			mockRun: func(m *MockSocialService) {
				m.On("GetFollowing", mock.Anything, requesterID, targetID, 20, 0, false).Return(nil, service.ErrUserNotFound)
			},
			expectedStatus: http.StatusNotFound,
			validateBody: func(t *testing.T, body string) {
				t.Helper()
				assert.Contains(t, body, "USER_NOT_FOUND")
				assert.Contains(t, body, "User not found")
			},
		},
		{
			name:           "Forbidden - private profile",
			targetIDPath:   targetID.String(),
			requesterIDHdr: requesterID.String(),
			queryParams:    "",
			mockRun: func(m *MockSocialService) {
				m.On("GetFollowing", mock.Anything, requesterID, targetID, 20, 0, false).Return(nil, service.ErrAccessDenied)
			},
			expectedStatus: http.StatusForbidden,
			validateBody: func(t *testing.T, body string) {
				t.Helper()
				assert.Contains(t, body, "FORBIDDEN")
				assert.Contains(t, body, "Access to this user's following list is restricted")
			},
		},
		{
			name:           "Internal Error - service error",
			targetIDPath:   targetID.String(),
			requesterIDHdr: requesterID.String(),
			queryParams:    "",
			mockRun: func(m *MockSocialService) {
				m.On("GetFollowing", mock.Anything, requesterID, targetID, 20, 0, false).Return(nil, errUnexpectedService)
			},
			expectedStatus: http.StatusInternalServerError,
			validateBody: func(t *testing.T, body string) {
				t.Helper()
				assert.Contains(t, body, "INTERNAL_ERROR")
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			mockSvc := new(MockSocialService)
			if tt.mockRun != nil {
				tt.mockRun(mockSvc)
			}

			h := handler.NewSocialHandler(mockSvc)

			r := chi.NewRouter()
			r.Get("/users/{user_id}/following", h.GetFollowing)

			url := "/users/" + tt.targetIDPath + "/following"
			if tt.queryParams != "" {
				url += "?" + tt.queryParams
			}

			req := httptest.NewRequest(http.MethodGet, url, nil)
			if tt.requesterIDHdr != "" {
				req.Header.Set("X-User-Id", tt.requesterIDHdr)
			}

			rr := httptest.NewRecorder()
			r.ServeHTTP(rr, req)

			assert.Equal(t, tt.expectedStatus, rr.Code)

			if tt.validateBody != nil {
				tt.validateBody(t, rr.Body.String())
			}
		})
	}
}
internal/handler/social_test.go:434: 434-467 lines are duplicate of `internal/handler/social_test.go:749-782` (dupl)
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			mockSvc := new(MockSocialService)
			if tt.mockRun != nil {
				tt.mockRun(mockSvc)
			}

			h := handler.NewSocialHandler(mockSvc)

			r := chi.NewRouter()
			r.Get("/users/{user_id}/following", h.GetFollowing)

			url := "/users/" + tt.targetIDPath + "/following"
			if tt.queryParams != "" {
				url += "?" + tt.queryParams
			}

			req := httptest.NewRequest(http.MethodGet, url, nil)
			if tt.requesterIDHdr != "" {
				req.Header.Set("X-User-Id", tt.requesterIDHdr)
			}

			rr := httptest.NewRecorder()
			r.ServeHTTP(rr, req)

			assert.Equal(t, tt.expectedStatus, rr.Code)

			if tt.validateBody != nil {
				tt.validateBody(t, rr.Body.String())
			}
		})
	}
internal/handler/user_test.go:412: 412-444 lines are duplicate of `internal/handler/user_test.go:683-715` (dupl)
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			mockSvc := new(MockUserService)
			if tt.mockRun != nil {
				tt.mockRun(mockSvc)
			}

			h := handler.NewUserHandler(mockSvc)

			r := chi.NewRouter()
			r.Put("/users/profile", h.UpdateUserProfile)

			req := httptest.NewRequest(http.MethodPut, "/users/profile", strings.NewReader(tt.requestBody))
			if tt.requesterIDHdr != "" {
				req.Header.Set("X-User-Id", tt.requesterIDHdr)
			}

			if tt.contentType != "" {
				req.Header.Set("Content-Type", tt.contentType)
			}

			rr := httptest.NewRecorder()
			r.ServeHTTP(rr, req)

			assert.Equal(t, tt.expectedStatus, rr.Code)

			if tt.validateBody != nil {
				tt.validateBody(t, rr.Body.String())
			}
		})
	}
tests/component/notification_test.go:258: 258-292 lines are duplicate of `tests/component/notification_test.go:731-765` (dupl)
func TestGetNotificationsComponent_Unauthorized(t *testing.T) {
	t.Parallel()

	mockRepo := new(MockNotificationRepo)
	mockUserRepo := new(MockUserRepo)
	svc := service.NewNotificationService(mockRepo, mockUserRepo)

	c := &app.Container{
		NotificationService: svc,
		Config:              config.Instance,
	}
	c.HealthService = service.NewHealthService(nil, nil)

	srv := server.NewServerWithContainer(c)
	handler := srv.Handler

	req := httptest.NewRequest(http.MethodGet, "/api/v1/user-management/notifications", nil)
	// No X-User-Id header

	rr := httptest.NewRecorder()
	handler.ServeHTTP(rr, req)

	assert.Equal(t, http.StatusUnauthorized, rr.Code)

	var apiResp struct {
		Success bool      `json:"success"`
		Error   dto.Error `json:"error"`
	}

	err := json.Unmarshal(rr.Body.Bytes(), &apiResp)
	require.NoError(t, err)
	require.False(t, apiResp.Success)

	assert.Equal(t, "UNAUTHORIZED", apiResp.Error.Code)
}
tests/component/social_test.go:608: 608-677 lines are duplicate of `tests/component/social_test.go:1094-1163` (dupl)
func TestGetFollowingComponent_ValidationError_InvalidUUID(t *testing.T) {
	t.Parallel()

	mockUserRepo := new(MockUserRepo)
	mockSocialRepo := new(MockSocialRepoComponent)
	mockTokenStore := new(MockTokenStore)

	userSvc := service.NewUserService(mockUserRepo, mockTokenStore)
	socialSvc := service.NewSocialService(mockUserRepo, mockSocialRepo)

	c := &app.Container{
		UserService:   userSvc,
		SocialService: socialSvc,
		Config:        config.Instance,
	}
	c.HealthService = service.NewHealthService(nil, nil)

	srv := server.NewServerWithContainer(c)
	handler := srv.Handler

	requesterID := uuid.New()

	req := httptest.NewRequest(http.MethodGet, "/api/v1/user-management/users/invalid-uuid/following", nil)
	req.Header.Set("X-User-Id", requesterID.String())

	rr := httptest.NewRecorder()

	handler.ServeHTTP(rr, req)

	assert.Equal(t, http.StatusUnprocessableEntity, rr.Code)
	assert.Contains(t, rr.Body.String(), "VALIDATION_ERROR")
}

func TestGetFollowingComponent_ValidationError_InvalidLimit(t *testing.T) {
	t.Parallel()

	mockUserRepo := new(MockUserRepo)
	mockSocialRepo := new(MockSocialRepoComponent)
	mockTokenStore := new(MockTokenStore)

	userSvc := service.NewUserService(mockUserRepo, mockTokenStore)
	socialSvc := service.NewSocialService(mockUserRepo, mockSocialRepo)

	c := &app.Container{
		UserService:   userSvc,
		SocialService: socialSvc,
		Config:        config.Instance,
	}
	c.HealthService = service.NewHealthService(nil, nil)

	srv := server.NewServerWithContainer(c)
	handler := srv.Handler

	targetUserID := uuid.New()
	requesterID := uuid.New()

	req := httptest.NewRequest(
		http.MethodGet,
		"/api/v1/user-management/users/"+targetUserID.String()+"/following?limit=0",
		nil,
	)
	req.Header.Set("X-User-Id", requesterID.String())

	rr := httptest.NewRecorder()

	handler.ServeHTTP(rr, req)

	assert.Equal(t, http.StatusBadRequest, rr.Code)
	assert.Contains(t, rr.Body.String(), "VALIDATION_ERROR")
}
tests/component/social_test.go:1464: 1464-1615 lines are duplicate of `tests/component/social_test.go:1896-2045` (dupl)
func TestFollowUserComponent_Forbidden_UserIdMismatch(t *testing.T) {
	t.Parallel()

	mockUserRepo := new(MockUserRepo)
	mockSocialRepo := new(MockSocialRepoComponent)
	mockTokenStore := new(MockTokenStore)

	userSvc := service.NewUserService(mockUserRepo, mockTokenStore)
	socialSvc := service.NewSocialService(mockUserRepo, mockSocialRepo)

	c := &app.Container{
		UserService:   userSvc,
		SocialService: socialSvc,
		Config:        config.Instance,
	}
	c.HealthService = service.NewHealthService(nil, nil)

	srv := server.NewServerWithContainer(c)
	handler := srv.Handler

	requesterID := uuid.New()
	differentUserID := uuid.New()
	targetUserID := uuid.New()

	// Non-admin trying to follow on behalf of another user
	req := httptest.NewRequest(
		http.MethodPost,
		"/api/v1/user-management/users/"+differentUserID.String()+"/follow/"+targetUserID.String(),
		nil,
	)
	req.Header.Set("X-User-Id", requesterID.String())

	rr := httptest.NewRecorder()

	handler.ServeHTTP(rr, req)

	assert.Equal(t, http.StatusForbidden, rr.Code)
	assert.Contains(t, rr.Body.String(), "FORBIDDEN")
}

func TestFollowUserComponent_Unauthorized_MissingHeader(t *testing.T) {
	t.Parallel()

	mockUserRepo := new(MockUserRepo)
	mockSocialRepo := new(MockSocialRepoComponent)
	mockTokenStore := new(MockTokenStore)

	userSvc := service.NewUserService(mockUserRepo, mockTokenStore)
	socialSvc := service.NewSocialService(mockUserRepo, mockSocialRepo)

	c := &app.Container{
		UserService:   userSvc,
		SocialService: socialSvc,
		Config:        config.Instance,
	}
	c.HealthService = service.NewHealthService(nil, nil)

	srv := server.NewServerWithContainer(c)
	handler := srv.Handler

	followerID := uuid.New()
	targetUserID := uuid.New()

	// Missing X-User-Id header
	req := httptest.NewRequest(
		http.MethodPost,
		"/api/v1/user-management/users/"+followerID.String()+"/follow/"+targetUserID.String(),
		nil,
	)

	rr := httptest.NewRecorder()

	handler.ServeHTTP(rr, req)

	assert.Equal(t, http.StatusUnauthorized, rr.Code)
	assert.Contains(t, rr.Body.String(), "UNAUTHORIZED")
}

func TestFollowUserComponent_ValidationError_InvalidUserUUID(t *testing.T) {
	t.Parallel()

	mockUserRepo := new(MockUserRepo)
	mockSocialRepo := new(MockSocialRepoComponent)
	mockTokenStore := new(MockTokenStore)

	userSvc := service.NewUserService(mockUserRepo, mockTokenStore)
	socialSvc := service.NewSocialService(mockUserRepo, mockSocialRepo)

	c := &app.Container{
		UserService:   userSvc,
		SocialService: socialSvc,
		Config:        config.Instance,
	}
	c.HealthService = service.NewHealthService(nil, nil)

	srv := server.NewServerWithContainer(c)
	handler := srv.Handler

	requesterID := uuid.New()
	targetUserID := uuid.New()

	req := httptest.NewRequest(
		http.MethodPost,
		"/api/v1/user-management/users/invalid-uuid/follow/"+targetUserID.String(),
		nil,
	)
	req.Header.Set("X-User-Id", requesterID.String())

	rr := httptest.NewRecorder()

	handler.ServeHTTP(rr, req)

	assert.Equal(t, http.StatusUnprocessableEntity, rr.Code)
	assert.Contains(t, rr.Body.String(), "VALIDATION_ERROR")
}

func TestFollowUserComponent_ValidationError_InvalidTargetUUID(t *testing.T) {
	t.Parallel()

	mockUserRepo := new(MockUserRepo)
	mockSocialRepo := new(MockSocialRepoComponent)
	mockTokenStore := new(MockTokenStore)

	userSvc := service.NewUserService(mockUserRepo, mockTokenStore)
	socialSvc := service.NewSocialService(mockUserRepo, mockSocialRepo)

	c := &app.Container{
		UserService:   userSvc,
		SocialService: socialSvc,
		Config:        config.Instance,
	}
	c.HealthService = service.NewHealthService(nil, nil)

	srv := server.NewServerWithContainer(c)
	handler := srv.Handler

	requesterID := uuid.New()

	req := httptest.NewRequest(
		http.MethodPost,
		"/api/v1/user-management/users/"+requesterID.String()+"/follow/invalid-uuid",
		nil,
	)
	req.Header.Set("X-User-Id", requesterID.String())

	rr := httptest.NewRecorder()

	handler.ServeHTTP(rr, req)

	assert.Equal(t, http.StatusUnprocessableEntity, rr.Code)
	assert.Contains(t, rr.Body.String(), "VALIDATION_ERROR")
}
tests/dependency/social_service_test.go:244: 244-287 lines are duplicate of `tests/dependency/social_service_test.go:578-621` (dupl)
	t.Run("Success_PublicProfile", func(t *testing.T) {
		t.Parallel()

		fix := setupSocialTest(t)
		targetUserID := uuid.New()
		targetUser := createTestUserForSocial(targetUserID)
		publicPrivacy := &dto.PrivacyPreferences{ProfileVisibility: "public"}
		now := time.Now()

		followedUsers := []dto.User{
			{
				UserID:    uuid.New().String(),
				Username:  "followed1",
				IsActive:  true,
				CreatedAt: now,
				UpdatedAt: now,
			},
			{
				UserID:    uuid.New().String(),
				Username:  "followed2",
				IsActive:  true,
				CreatedAt: now,
				UpdatedAt: now,
			},
		}

		fix.mockUserRepo.On("FindUserByID", mock.Anything, targetUserID).Return(targetUser, nil).Once()
		fix.mockUserRepo.On("FindPrivacyPreferencesByUserID", mock.Anything, targetUserID).Return(publicPrivacy, nil).Once()
		fix.mockSocialRepo.On("GetFollowing", mock.Anything, targetUserID, 20, 0).Return(followedUsers, 2, nil).Once()

		rr := httptest.NewRecorder()
		fix.handler.ServeHTTP(rr, newGetFollowingRequest(t, targetUserID, fix.requesterID, ""))

		require.Equal(t, http.StatusOK, rr.Code)

		var resp struct {
			Success bool                         `json:"success"`
			Data    dto.GetFollowedUsersResponse `json:"data"`
		}
		require.NoError(t, json.Unmarshal(rr.Body.Bytes(), &resp))
		assert.True(t, resp.Success)
		assert.Equal(t, 2, resp.Data.TotalCount)
		assert.Len(t, resp.Data.FollowedUsers, 2)
	})
tests/dependency/social_service_test.go:538: 538-556 lines are duplicate of `tests/dependency/social_service_test.go:870-888` (dupl)
	t.Run("InternalError_RepositoryFailure", func(t *testing.T) {
		t.Parallel()

		fix := setupSocialTest(t)
		targetUserID := uuid.New()
		targetUser := createTestUserForSocial(targetUserID)
		publicPrivacy := &dto.PrivacyPreferences{ProfileVisibility: "public"}

		fix.mockUserRepo.On("FindUserByID", mock.Anything, targetUserID).Return(targetUser, nil).Once()
		fix.mockUserRepo.On("FindPrivacyPreferencesByUserID", mock.Anything, targetUserID).Return(publicPrivacy, nil).Once()
		fix.mockSocialRepo.On("GetFollowing", mock.Anything, targetUserID, 20, 0).
			Return(nil, 0, errDatabaseFailure).Once()

		rr := httptest.NewRecorder()
		fix.handler.ServeHTTP(rr, newGetFollowingRequest(t, targetUserID, fix.requesterID, ""))

		assert.Equal(t, http.StatusInternalServerError, rr.Code)
		assert.Contains(t, rr.Body.String(), "INTERNAL_ERROR")
	})
cmd/api/main.go:105:20: do not compare errors directly "err != http.ErrServerClosed", use "!errors.Is(err, http.ErrServerClosed)" instead (err113)
		if err != nil && err != http.ErrServerClosed {
		                 ^
internal/config/config.go:93:15: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
		if _, ok := err.(viper.ConfigFileNotFoundError); ok {
		            ^
internal/config/config.go:104:15: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
		if _, ok := err.(viper.ConfigFileNotFoundError); ok {
		            ^
internal/config/config.go:115:15: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
		if _, ok := err.(viper.ConfigFileNotFoundError); ok {
		            ^
internal/redis/redis.go:132:1: unexported method "logStateChange" for struct "Service" should be placed after the exported method "DeleteDeleteToken" (funcorder)
func (s *Service) logStateChange(currentStatus string) {
^
internal/repository/social_repository.go:59:1: unexported method "countFollowing" for struct "SQLSocialRepository" should be placed after the exported method "GetRecentFavorites" (funcorder)
func (r *SQLSocialRepository) countFollowing(ctx context.Context, userID uuid.UUID) (int, error) {
^
internal/repository/social_repository.go:76:1: unexported method "fetchFollowing" for struct "SQLSocialRepository" should be placed after the exported method "GetRecentFavorites" (funcorder)
func (r *SQLSocialRepository) fetchFollowing(
^
internal/repository/social_repository.go:167:1: unexported method "countFollowers" for struct "SQLSocialRepository" should be placed after the exported method "GetRecentFavorites" (funcorder)
func (r *SQLSocialRepository) countFollowers(ctx context.Context, userID uuid.UUID) (int, error) {
^
internal/repository/social_repository.go:184:1: unexported method "fetchFollowers" for struct "SQLSocialRepository" should be placed after the exported method "GetRecentFavorites" (funcorder)
func (r *SQLSocialRepository) fetchFollowers(
^
internal/repository/user_repository.go:338:1: unexported method "executeUpdateQuery" for struct "SQLUserRepository" should be placed after the exported method "SearchUsers" (funcorder)
func (r *SQLUserRepository) executeUpdateQuery(ctx context.Context, query string, args []any) (*dto.User, error) {
^
internal/service/user_service.go:145:1: unexported method "canViewProfile" for struct "UserServiceImpl" should be placed after the exported method "SearchUsers" (funcorder)
func (s *UserServiceImpl) canViewProfile(
^
internal/service/user_service.go:171:1: unexported method "buildProfileResponse" for struct "UserServiceImpl" should be placed after the exported method "SearchUsers" (funcorder)
func (s *UserServiceImpl) buildProfileResponse(
^
internal/config/config.go:79:6: Function 'Load' has too many statements (41 > 40) (funlen)
func Load() *Config {
     ^
internal/server/server_test.go:71:6: Function 'TestRegisterRoutesWithHandlers_HealthReady' is too long (73 > 60) (funlen)
func TestRegisterRoutesWithHandlers_HealthReady(t *testing.T) {
     ^
tests/component/user_test.go:286:6: Function 'TestUpdateUserProfileComponent_Success' is too long (61 > 60) (funlen)
func TestUpdateUserProfileComponent_Success(t *testing.T) {
     ^
internal/app/container.go:40:1: cognitive complexity 22 of func `NewContainer` is high (> 20) (gocognit)
func NewContainer(cfg ContainerConfig) (*Container, error) {
^
internal/service/user_service_test.go:335:36: string `Bio` has 3 occurrences, make it a constant (goconst)
		Bio:       func() *string { s := "Bio"; return &s }(),
		                                 ^
tests/performance/notification_benchmark_test.go:100:13: string `/api/v1/user-management/notifications` has 3 occurrences, make it a constant (goconst)
	reqPath := "/api/v1/user-management/notifications"
	           ^
cmd/api/main.go:119:59: Magic number: 5, in <argument> detected (mnd)
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	                                                         ^
internal/server/server.go:18:17: Magic number: 10, in <operation> detected (mnd)
	readTimeout := 10 * time.Second
	               ^
internal/server/server.go:19:18: Magic number: 30, in <operation> detected (mnd)
	writeTimeout := 30 * time.Second
	                ^
internal/config/config.go:92:5: avoid inline error handling using `if err := ...; err != nil`; use plain assignment `err := ...` (noinlineerr)
	if err := viper.ReadInConfig(); err != nil {
	   ^
internal/config/config.go:103:5: avoid inline error handling using `if err := ...; err != nil`; use plain assignment `err := ...` (noinlineerr)
	if err := viper.MergeInConfig(); err != nil {
	   ^
internal/config/config.go:114:5: avoid inline error handling using `if err := ...; err != nil`; use plain assignment `err := ...` (noinlineerr)
	if err := viper.MergeInConfig(); err != nil {
	   ^
internal/config/config.go:151:5: avoid inline error handling using `if err := ...; err != nil`; use plain assignment `err := ...` (noinlineerr)
	if err := viper.Unmarshal(&cfg); err != nil {
	   ^
internal/logger/logger.go:35:7: avoid inline error handling using `if err := ...; err != nil`; use plain assignment `err := ...` (noinlineerr)
			if err := handler.Handle(ctx, r); err != nil && firstErr == nil {
			   ^
tests/dependency/user_service_test.go:118:5: avoid inline error handling using `if err := ...; err != nil`; use plain assignment `err := ...` (noinlineerr)
	if err := args.Error(1); err != nil {
	   ^
tests/dependency/user_service_test.go:144:5: avoid inline error handling using `if err := ...; err != nil`; use plain assignment `err := ...` (noinlineerr)
	if err := args.Error(1); err != nil {
	   ^
internal/handler/notification.go:1:1: directive `//nolint:mnd // placeholder values for stub handlers` is unused for linter "mnd" (nolintlint)
//nolint:mnd // placeholder values for stub handlers
^
cmd/api/main.go:88:31: use slog.DiscardHandler instead (sloglint)
		handlers = append(handlers, slog.NewTextHandler(io.Discard, nil))
		                            ^
internal/config/config.go:1:1: ST1000: at least one file in a package should have a package comment (staticcheck)
package config
^
internal/logger/logger.go:1:1: ST1000: at least one file in a package should have a package comment (staticcheck)
package logger
^
internal/server/routes.go:1:1: ST1000: at least one file in a package should have a package comment (staticcheck)
package server
^
internal/server/server.go:1:1: ST1000: at least one file in a package should have a package comment (staticcheck)
package server
^
internal/validation/validator.go:106:6: QF1001: could apply De Morgan's law (staticcheck)
		if !((r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') || r == '_') {
		   ^
internal/handler/notification_test.go:119:15: error returned from external package is unwrapped: sig: func (github.com/stretchr/testify/mock.Arguments).Error(index int) error (wrapcheck)
		return nil, args.Error(1)
		            ^
internal/handler/notification_test.go:121:15: error returned from external package is unwrapped: sig: func (github.com/stretchr/testify/mock.Arguments).Error(index int) error (wrapcheck)
	return resp, args.Error(1)
	             ^
cmd/api/main.go:53:3: missing whitespace above this line (too many statements above if) (wsl_v5)
		opts := &slog.HandlerOptions{
		^
internal/config/config.go:156:2: missing whitespace above this line (too many lines above return) (wsl_v5)
	return Instance
	^
internal/server/routes.go:73:2: missing whitespace above this line (invalid statement above expr) (wsl_v5)
	r.Use(middleware.Timeout(timeout))
	^
internal/service/notification_service_test.go:210:4: missing whitespace above this line (no shared variables above expr) (wsl_v5)
			tt.setupMock(mockRepo)
			^
internal/service/notification_service_test.go:337:4: missing whitespace above this line (no shared variables above expr) (wsl_v5)
			tt.setupMock(mockRepo)
			^
internal/service/notification_service_test.go:418:4: missing whitespace above this line (no shared variables above expr) (wsl_v5)
			tt.setupMock(mockRepo)
			^
internal/service/notification_service_test.go:495:4: missing whitespace above this line (no shared variables above expr) (wsl_v5)
			tt.setupMock(mockRepo)
			^
55 issues:
* cyclop: 1
* dupl: 10
* err113: 1
* errorlint: 3
* funcorder: 8
* funlen: 3
* gocognit: 1
* goconst: 2
* mnd: 3
* noinlineerr: 7
* nolintlint: 1
* sloglint: 1
* staticcheck: 5
* wrapcheck: 2
* wsl_v5: 7
